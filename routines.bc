### routines.bc

# Print the Pythagorean triple generated 
# by parameters m and n, and return the hypotenuse
define pythagtriple(m,n) {
    print abs(n*n-m*m), "\n"
    print abs(2*m*n), "\n"
    return m*m+n*n
}

# Print the Pythagorean quadruple generated 
# by parameters m, n, p, and q, and return the hypotenuse
define pythagquadruple(m,n,p,q) {
    print abs(n*n+m*m-p*p-q*q), "\n"
    print abs(2*(m*q+n*p)), "\n"
    print abs(2*(n*q-m*p)), "\n"
    return m*m+n*n+p*p+q*q
}

# Prints the angle x, presumed as a decimal number of degrees,
# in DMS (degrees, minutes, seconds) notation
define void dd2dms(x) { 
    d = int(x)
    m = abs(int(frac(x)*60))
    s = abs(frac(frac(x)*60)*60)
    print d,"°",m,"′",s,"″\n"
}

# Iteratively applies Newton's Method n times, printing each result,
# with initial guess x (parameter) and (global) function f 
define void newtoniter(x,n) { 
    auto i
    for(i=0; i<=n; x -= f(x)/derivative(x))
        print "n=", i++, " | ", x, "\n"
}

# Print the roots and vertex coordinates of ax²+bx+c
define void quadratic(a,b,c) {
    print "For vertex (h,k) and roots r[1] and r[2],\n"

    h = -b/(2*a)
    k = a*h^2 + b*h + c
    print "h = ", h, "\n"
    print "k = ", k, "\n"

    if(b^2-4*a*c < 0) {
        print "The roots are non-real: \n"
        scale /= 2
        print h/1, " ± i", sqrt(k/a), "\n"
        scale *= 2
    } else {
        r[1] = h - sqrt(-k/a)
        r[2] = h + sqrt(-k/a)
        print "r[1] = ", r[1], "\n"
        print "r[2] = ", r[2], "\n"
    }
}

# Print the roots and local extrema coordinates of ax³+bx²+cx+d
define void cubic(a,b,c,d) {
    # 3a*x^2 + b*x + c
    # 6a*x + b 
    print "For inflection point at i,\n"
    print "local extrema at h[1] and h[2],\n"
    print "and roots r[1] and r[2] and r[3],\n"
}

# Print the roots and local extrema coordinates of ax⁴+bx³+cx²+dx+e
define void quartic(a,b,c,d,e) {
    #print "For TK jerk points at ,\n"
    print "For inflection points at i[1] and i[2],\n"
    print "local extrema at h[1] and h[2] and h[3],\n"
    print "and roots r[1] and r[2] and r[3] and r[4],\n"
}

# Print the coefficients of the simple continued fraction representation of x
# as well as each convergent obtained by truncating at that coefficient,
# which are successively better rational approximations to the number x
define void contfrac(x) {
    auto i, j, k, l, a[], h[], k[], r

    if(x == int(x)) { print x, " = ", x, "/", 1, "\n"; return }

    r = x
    a[0] = int(r)
    h[0] = a[0]
    k[0] = 1
    l = length(a[0])

    r = 1/(r-a[0])
    a[1] = int(r)
    h[1] = a[1]*h[0]+1
    k[1] = a[1]
    l = max(l,length(a[1]))

    for(i=2; x!=h[i-1]/k[i-1]; ++i) {
        r = 1/(r-a[i-1])
        a[i] = int(r)
        h[i] = a[i]*h[i-1]+h[i-2]
        k[i] = a[i]*k[i-1]+k[i-2]
        l = max(l,length(a[i]))
    }
    
    for(j=0; j<i; ++j) {
        for(k=l-length(a[j]); k; k--) { print " " }
        print a[j], " | ", h[j]/k[j], " = ", h[j], "/", k[j], "\n"
    }
}

# Print n expressed in bases 2, 3, ..., 36
define void bases(n) {
    auto i, base
    base = obase
    for(i=2; i<=36; i++) {
        obase = A
        if (i<A) print " "
        print "  ", i, " |"
        if (i<H) print " "
        obase = i
        print n, "\n"
    }
    obase = base
}

# Print the prime integer factorization of n
define void factor(n) {
    auto i, s, p
    s = scale
    scale = 0
    for(i=1; n!=1; i++) {
        p=prime(i)
        while(n % p == 0) {
            print p, " "
            n/=p 
        }
    } 
    print "✓\n"
    scale = s
    return
}

# Convert 2-dimensional rectangular coordinates to polar coordinates
define void rect2polar(x,y) {
    r = sqrt(x^2+y^2)
    theta = atan2(y,x)
    print "r = ", r, "\n"
    print "theta = ", theta, "\n"
    return
}

# Convert 2-dimensional polar coordinates to rectangular coordinates
define void polar2rect(r,theta) {
    x = r*c(theta)
    y = r*s(theta)
    print "x = ", x, "\n"
    print "y = ", y, "\n"
    return
}

# Convert 3-dimensional rectilinear coordinates to cylindrical coordinates
define void rect2cyl(x,y,zed) {
    rect2polar(x,y)
    z = zed
    print "z = ", z, "\n"
    return
}

# Convert 3-dimensional cylindrical coordinates to rectilinear coordinates
define void cyl2rect(r,theta,zed) {
    polar2rect(r,theta)
    z = zed
    print "z = ", z, "\n"
    return
}

# Convert 3-dimensional rectilinear coordinates to spherical coordinates
# This follows the "mathematical" conventions for spherical coordinates
define void rect2sphere(x,y,z) {
    rho = sqrt(x^2+y^2+z^2)
    theta = atan2(y,x)
    phi = arccos(z/rho)
    print "rho = ", rho, "\n"
    print "theta = ", theta, "\n"
    print "phi = ", phi, "\n"
    return
}

# Convert 3-dimensional spherical coordinates to rectilinear coordinates
# This follows the "mathematical" conventions for spherical coordinates
define void sphere2rect(rho,theta,phi) {
    x = rho*s(phi)*c(theta)
    y = rho*s(phi)*s(theta)
    z = rho*c(phi)
    print "x = ", x, "\n"
    print "y = ", y, "\n"
    print "z = ", z, "\n"
    return
}

# Print the sequence of positive integers that results from 
# iteratively applying the function prescribed by the Collatz Conjecture.
define void collatz(n) { 
    auto s
    s = scale
    scale = 0
    collatz_(n)
    scale = s
}

# Recursive helper function to collatz(n)
define collatz_(n) {
    if(n==1)
        return 1
    print n, " → " 
    if(n%2) {
        return collatz_(3*n+1)
    } else {
        return collatz_(n/2)
    }
}

# Print every way that m can be written as a sum 
# of powers of consecutive positive integers.
define void sumofpowers(m) {
    auto s, n, i, j, cap, powers[], any
    s = scale
    for(n=1; 2^n<m; n++) {
        cap = pow(m,1/n)+1
        scale = 0
        for(i=1; i<cap; i++)
            powers[i] = i^n
        i = j = sum = any = 1
        while(j < cap) {
            if(sum >= m) {
                if(sum == m) {
                    if(any) {print "For n = ", n, "\n"; any = 0; }
                    print "  ", m, " = ", i, "ⁿ + ⋯  + ", j, "ⁿ\n"
                } 
                sum -= powers[i++]
            } else {
                sum += powers[++j]
            }
        }
        scale = s
    }
    print "✓\n"
}

# Print n uniquely as a sum of non-adjacent Fibonacci numbers
define void zeckendorf(n) {
    auto  f
    f = fibonacci(int(l(n*sqrt(5)+1/2)/l((1+sqrt(5))/2)))
    print f
    if(n-f) {
        print " + "
        zeckendorf(n-f)
    } else {
        print " ✓\n"
    }
}

