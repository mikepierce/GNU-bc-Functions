### routines.bc

# Display the Pythagorean triple generated by integers m and n,
# and return the hypotenuse
define pythagtriple(m,n) {
    print abs(n*n-m*m), "\n"
    print abs(2*m*n), "\n"
    return m*m+n*n
}

# Iteratively applies Newton's Method n times, printing each result,
# with initial guess x (parameter) and (global) functions f and ff=f'
define void newtoniter(x,n) { 
    auto i
    for (i=0; i<=n; x -= f(x)/ff(x))
        print "n=", i++, " | ", x, "\n"
}

# Print the roots and vertex coordinates of ax^2+bx+c
define void quadratic(a,b,c) {
    print "For vertex (h,k) and roots r[1] and r[2],\n"

    h = -b/(2*a)
    k = a*h^2 + b*h + c
    print "h = ", h, "\n"
    print "k = ", k, "\n"

    if (b^2-4*a*c < 0) {
        print "The roots are non-real: \n"
        scale/=2
        print h/1, " ± i", sqrt(k/a), "\n"
        scale*=2
    } else {
        r[1] = h - sqrt(-k/a)
        r[2] = h + sqrt(-k/a)
        print "r[1] = ", r[1], "\n"
        print "r[2] = ", r[2], "\n"
    }
}

# Display increasingly better rational approximations 
# to the decimal number x obtained by truncating its continued fraction
define void rational(x) {
    auto i,a,h,k,m
    m = x
    if (x == int(x)) { print "The number is an integer\n"; return }

    a[0] = int(x)
    h[0] = a[0]
    k[0] = 1
    x=1/(x-a[0])

    a[1] = int(x)
    h[1] = a[1]*h[0]+1
    k[1] = a[1]
    x=1/(x-a[1])

    for(i=1; m!=h[i]/k[i]; ++i){
        print h[i]/k[i], " = ", h[i], "/", k[i], "\n"
        a[i+1] = int(x)
        h[i+1] = a[i+1]*h[i]+h[i-1]
        k[i+1] = a[i+1]*k[i]+k[i-1]
        x=1/(x-a[i+1])
    }
    print m/1, " = ", h[i], "/", k[i], " ✓\n"
}

# Display n expressed in bases 2,3,…,36
define void bases(n) {
    auto i,base
    base = obase
    for (i=2; i<=36; i++) {
        obase = 10
        if (i<10) print " "
        print "  ", i, " | "
        obase = i
        print n, "\n"
    }
    obase = base
}

