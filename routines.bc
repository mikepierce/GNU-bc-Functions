### routines.bc

# Display the Pythagorean triple generated by parameters m and n,
# and return the hypotenuse
define pythagtriple(m,n) {
    print abs(n*n-m*m), "\n"
    print abs(2*m*n), "\n"
    return m*m+n*n
}

# Display the Pythagorean quadruple generated by parameters m, n, p, and q,
# and return the hypotenuse
define pythagquadruple(m,n,p,q) {
    print abs(n*n+m*m-p*p-q*q), "\n"
    print abs(2*(m*q+n*p)), "\n"
    print abs(2*(n*q-m*p)), "\n"
    return m*m+n*n+p*p+q*q
}

# Iteratively applies Newton's Method n times, printing each result,
# with initial guess x (parameter) and (global) functions f and ff=f'
define void newtoniter(x,n) { 
    auto i
    for (i=0; i<=n; x -= f(x)/ff(x))
        print "n=", i++, " | ", x, "\n"
}

# Print the roots and vertex coordinates of ax^2+bx+c
define void quadratic(a,b,c) {
    print "For vertex (h,k) and roots r[1] and r[2],\n"

    h = -b/(2*a)
    k = a*h^2 + b*h + c
    print "h = ", h, "\n"
    print "k = ", k, "\n"

    if (b^2-4*a*c < 0) {
        print "The roots are non-real: \n"
        scale/=2
        print h/1, " ± i", sqrt(k/a), "\n"
        scale*=2
    } else {
        r[1] = h - sqrt(-k/a)
        r[2] = h + sqrt(-k/a)
        print "r[1] = ", r[1], "\n"
        print "r[2] = ", r[2], "\n"
    }
}

# Print increasingly better rational approximations 
# to the decimal number x obtained by truncating its continued fraction
define void rational(x) {
    auto i,a,h,k,m
    m = x

    a[0] = int(x)
    h[0] = a[0]
    k[0] = 1
    if (m == h[0]/k[0]) { print h[0]/k[0], " is an integer ✓\n"; return }
    x=1/(x-a[0])

    a[1] = int(x)
    h[1] = a[1]*h[0]+1
    k[1] = a[1]
    if (m == h[1]/k[1]) { print h[1]/k[1], " = ", h[1], "/", k[1], " and is rational ✓\n"; return }
    x=1/(x-a[1])

    for (i=1; m!=h[i]/k[i]; ++i) {
        print h[i]/k[i], " = ", h[i], "/", k[i], "\n"
        a[i+1] = int(x)
        h[i+1] = a[i+1]*h[i]+h[i-1]
        k[i+1] = a[i+1]*k[i]+k[i-1]
        x=1/(x-a[i+1])
    }
    print m/1, " = ", h[i], "/", k[i], " ✓\n"
}

# Display n expressed in bases 2,3,…,36
define void bases(n) {
    auto i,base
    base = obase
    for (i=2; i<=36; i++) {
        obase = 10
        if (i<10) print " "
        print "  ", i, " | "
        obase = i
        print n, "\n"
    }
    obase = base
}

# Display the prime integer factorization of n
define void factor(n) {
    auto i, s, p
    s = scale
    scale = 0
    for (i=1; n!=1; i++) {
        p=prime(i)
        while (n % p == 0) {
            print p, " "
            n/=p 
        }
    } 
    print "✓\n"
    scale = s
    return
}

# Convert 2-dimensional rectangular coordinates to polar coordinates
define void rect2polar(x,y) {
    r = sqrt(x^2+y^2)
    theta = atan2(y,x)
    print "r = ", r, "\n"
    print "theta = ", theta, "\n"
    return
}

# Convert 2-dimensional polar coordinates to rectangular coordinates
define void polar2rect(r,theta) {
    x = r*c(theta)
    y = r*s(theta)
    print "x = ", x, "\n"
    print "y = ", y, "\n"
    return
}

# Convert 3-dimensional rectilinear coordinates to cylindrical coordinates
define void rect2cyl(x,y,zed) {
    rect2polar(x,y)
    z = zed
    print "z = ", z, "\n"
    return
}

# Convert 3-dimensional cylindrical coordinates to rectilinear coordinates
define void cyl2rect(r,theta,zed) {
    polar2rect(r,theta)
    z = zed
    print "z = ", z, "\n"
    return
}

# Convert 3-dimensional rectilinear coordinates to spherical coordinates
# This follows the "mathematical" conventions for spherical coordinates
define void rect2sphere(x,y,z) {
    rho = sqrt(x^2+y^2+z^2)
    theta = atan2(y,x)
    phi = arccos(z/rho)
    print "rho = ", rho, "\n"
    print "theta = ", theta, "\n"
    print "phi = ", phi, "\n"
    return
}

# Convert 3-dimensional spherical coordinates to rectilinear coordinates
# This follows the "mathematical" conventions for spherical coordinates
define void sphere2rect(rho,theta,phi) {
    x = rho*s(phi)*c(theta)
    y = rho*s(phi)*s(theta)
    z = rho*c(phi)
    print "x = ", x, "\n"
    print "y = ", y, "\n"
    print "z = ", z, "\n"
    return
}

# Print the sequence of positive integers that results from 
# iteratively applying the function prescribed by the Collatz Conjecture.
define void collatz(n) { 
    auto s
    s = scale
    scale = 0
    collatz_(n)
    scale = s
}

# Recursive helper function to collatz()
define collatz_(n) {
    if(n==1)
        return 1
    print n, " → "; 
    if (n%2) {
        return collatz_(3*n+1);
    } else {
        return collatz_(n/2);
    }
}

# Print every way that n can be written as a sum 
# of consecutive positive integers.
define void sumofpositiveintegers(n) { sumofpowers(n,1) }

# Print every way that m can be written as a sum 
# of nth powers of consecutive positive integers.
define void sumofpowers(m,n) {
    auto s, i, j, cap, powers[]
    print "n = ", n, "\n"
    cap = pow(m,1/n)+1
    s = scale
    scale = 0
    for (i=1; i<cap; i++) {
        powers[i] = i^n
    }
    i = j = sum = 1;
    while (i<cap) {
        if (sum >= m) {
            if (sum == m) {
                print m, " = ", i, "ⁿ + … + ", j, "ⁿ\n"
            } 
            sum -= powers[i];
            i+=1;
        } else {
            j+=1;
            sum += powers[j];
        }
    }
    print " ✓\n"
    scale = s
}
