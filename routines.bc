### routines.bc

# Display the Pythagorean triple generated by integers m and n,
# and return the hypotenuse
define pythagtriple(m,n) {
    print abs(n*n-m*m), "\n"
    print abs(2*m*n), "\n"
    return m*m+n*n
}

# Iteratively applies Newton's Method n times, printing each result,
# with initial guess x (parameter) and (global) functions f and ff=f'
define void newtoniter(x,n) { 
    auto i
    for (i=0; i<=n; x -= f(x)/ff(x))
        print "n=", i++, " | ", x, "\n"
}

# Print the roots and vertex coordinates of ax^2+bx+c
define void quadratic(a,b,c) {
    print "For vertex (h,k) and roots r[1] and r[2],\n"

    h = -b/(2*a)
    k = a*h^2 + b*h + c
    print "h = ", h, "\n"
    print "k = ", k, "\n"

    if (b^2-4*a*c < 0) {
        print "The roots are non-real: \n"
        scale/=2
        print h/1, " ± i", sqrt(k/a), "\n"
        scale*=2
    } else {
        r[1] = h - sqrt(-k/a)
        r[2] = h + sqrt(-k/a)
        print "r[1] = ", r[1], "\n"
        print "r[2] = ", r[2], "\n"
    }
}

# Display the first n rational approximations to the decimal number x
# obtained by truncating the continued fraction of x
define void rational(x,n) {
    auto i,a,h,k,m
    m = x
    if (x == int(x))
        print "The number is an integer\n"

    h[0] = int(x)
    k[0] = 1
    h[1] = int(1/(x-int(x)))*int(x)+1
    k[1] = int(1/(x-int(x)))

    for(i=0; i<=n; ++i){
        a[i] = int(x)
        if (i >= 2) {
            h[i] = a[i]*h[i-1]+h[i-2]
            k[i] = a[i]*k[i-1]+k[i-2]
        }
        if (m == h[i]/k[i]) {
            n = i
            print "The number is exactly ", h[i], "/", k[i], " up to scale\n"
            break
        }
        x=1/(x-a[i])
        print h[i]/k[i], " = ", h[i], "/", k[i], "\n"
    }
    print m/1, " is the number\n"
}

# Display n expressed in bases 2,3,…,36
define void bases(n) {
    auto i,base
    base = obase
    for (i=2; i<=36; i++) {
        obase = 10
        if (i<10) print " "
        print "  ", i, " | "
        obase = i
        print n, "\n"
    }
    obase = base
}

