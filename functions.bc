### functions.bc

################################################################################
### Helpful Constants and Functions

pi = 4*a(1)
ex = e(1)
define sgn(x) { if(x>0) return 1; if(x<0) return -1; }
define abs(x) { return sgn(x)*x }
define heavyside(x) { return (x>0) }
define max(x,y) { if(x>y) return x; return y}

# Return the integer-part of a number (not the floor)
define int(x) { auto s; s=scale; scale=0; x/=1; scale=s; return x; }

# Return the fractional-part of a number
define frac(x) { return x-int(x) }

################################################################################
### Logarithms & Exponentials

define ln(x) { return l(x) }
define log(x) { return l(x)/l(A) }
define logb(x,b) { return l(x)/l(b) }
define pow(x,n) { return e(n*l(x)) }

################################################################################
### Trigonometry

define rad2deg(x) { return x*(45/a(1)) }
define deg2rad(x) { return x*(a(1)/45) }
define dms2dd(d,m,s) { return d + (m/60) + (s/3600) }
define cos(x) { return c(x) }
define sin(x) { return s(x) }
define tan(x) { return s(x)/c(x) }
define sec(x) { return 1/c(x) }
define csc(x) { return 1/s(x) }
define cot(x) { return c(x)/s(x) }
define arccos(x) {
    pi = 4*a(1)
    if(x == 1) return 0
    if(x == -1) return pi 
    return pi/2 - a(x/sqrt(1-(x^2)))
}
define arcsin(x) { 
    pi = 4*a(1)
    if(x == 1) return pi/2
    if(x == -1) return -pi/2
    return sgn(x)*a(sqrt((1/(1-(x^2)))-1))
}
define arctan(x) { return a(x) }
define atan2(y,x) { 
    pi = 4*a(1)
    if(x == 0) return sgn(y)*pi/2
    if(x < 0) {
        if(y < 0)
            return a(y/x)-pi
        return a(y/x)+pi
    }
    return a(y/x)
}
define arcsec(x) { return arccos(1/x) }
define arccsc(x) { return arcsin(1/x) }
define arccot(x) { return (4*a(1))/2-a(x) }

define cosh(x) { return (e(x)+e(-x))/2 }
define sinh(x) { return (e(x)-e(-x))/2 }
define tanh(x) { return sinh(x)/cosh(x) }
define sech(x) { return 1/cosh(x) }
define csch(x) { return 1/sinh(x) }
define coth(x) { return 1/tanh(x) }

define arcosh(x) { return ln(x+sqrt(x^2-1)) }
define arsinh(x) { return ln(x+sqrt(x^2+1)) }
define artanh(x) { return (1/2)*ln((1+x)/(1-x))}
define arsech(x) { return arcosh(1/x) }
define arcsch(x) { return arsinh(1/x) }
define arcoth(x) { return artanh(1/x) }

################################################################################
### Combinatorics

define factorial(n) {
    auto i
    if((n<0) || (int(n)!= n)) {
        print "Error: factorials defined for positive integers only\n"
        return
    }
    factorial[0] = factorial[1] = 1
    for(i=n; factorial[i]==0; --i) {}
    for(++i; i<=n; ++i)
        factorial[i] = i*factorial[i-1]
    return factorial[n]
}

# Return nPk, the number of ways to permute k of n objects
define pick(n,k) {
    auto i, r
    if((n<0) || (k<0) || (int(n)!=n) || (int(k)!=k) ) {
        print "Error: permutations defined for positive integers only\n"
        return
    }
    r = n - k
    for(i=1; n>r; --n)
        i *= n
    return i
}

# Return nCk, the number of ways to choose k of n objects
define choose(n,k) {
    if((n<0) || (k<0) || (int(n)!=n) || (int(k)!=k)) {
        print "Error: combinations defined for positive integers only\n"
        return
    }
    if(n*(n+1)/2 + k >= 2^24) {
        return int(factorial(n)/(factorial(n-k)*factorial(k)))
    }
    return choose_(n,k)
}

# Dynamic, recursive helper function for choose(n,k)
define choose_(n,k) {
    auto i
    if((k==0) || (k==n))
        return 1
    i = n*(n+1)/2 + k
    if(choose[i] != 0)
        return choose[i]
    choose[i] = choose_(n-1,k) + choose_(n-1,k-1)
    return choose[i]
}

# Return the nth Fibonacci number
define fibonacci(n) {
    auto i
    if((n<1) || (int(n)!=n)) {
        print "Error: Fibonacci numbers indexed by positive integers\n"
        return
    }
    fibonacci[1] = fibonacci[2] = 1
    for(i=n; fibonacci[i]==0; --i) {}
    for(++i; i<=n; ++i)
        fibonacci[i] = fibonacci[i-1] + fibonacci[i-2]
    return fibonacci[n]
}

################################################################################
### Calculus

# Returns the derivative of the (global) function f at x
# using a finite central distance with eight points.
define derivative(x) {
    auto h, d
    h = A^-scale
    scale *= 2
    d = (3*f(x-4*h)-32*f(x-3*h)+168*f(x-2*h)-672*f(x-h)+672*f(x+h)-168*f(x+2*h)+32*f(x+3*h)-3*f(x+4*h))/(840*h)
    scale /= 2
    return d/1
}

# Returns the zero of the (global) function f
# that results from iteratively applying Newton's Method 
# with initial parameter x.
define newton(x) { 
    if (f(x)/9)
        return newton(x - f(x)/derivative(x))
    return x
}

# Returns the value of the definite integral 
# of the (global) function f between a and b.
define integral(a,b) {
    auto i
    scale *= 2
    i = integral_(a,b,0)
    scale /= 2
    return i/1
}

# Recursive helper function for integral(a,b)
define integral_(a,b,try) {
    auto left, midpoint, right
    midpoint = (a+b)/2
    left = boole_(a,midpoint)
    right = boole_(midpoint,b)
    if(abs(left + right - try) < e(-l(A) * scale/2))
        return left + right
    return integral_(a,midpoint,left) + integral_(midpoint,b,right)
}

# Boole's rule for approximate integration
define boole_(a,b) {
    auto h
    h = (b-a)/4
    return 2*(7*f(a)+32*f(a+h)+12*f(a+2*h)+32*f(a+3*h)+7*f(b))*h/45
}


################################################################################
### Number Theory

# Returns the nth prime integer
define prime(n) {
    auto i, s 
    prime[1] = 2
    prime[2] = 3
    for(i=n; prime[i]==0; --i) {}
    return prime_(i,n)
}

# Fill in the array of prime numbers prime[]
# beyond index j, up through k
define prime_(j,k) {
    auto i, n, flag, p, s
    s = scale
    scale = 0
    for(i=j+1; i<=k; ++i) {
        flag = 0;
        for(n=prime[i-1]+2; !flag; n=n+2) {
            flag = 1
            for(p=1; p<i; ++p) {
                if(n % prime[p] == 0) {flag=0; break;}
            }
            if(flag) {prime[i]=n; break;}
        }
    }
    scale = s
    return prime[k]
}

